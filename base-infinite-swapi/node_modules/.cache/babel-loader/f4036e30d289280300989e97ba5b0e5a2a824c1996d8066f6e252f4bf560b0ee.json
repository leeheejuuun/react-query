{"ast":null,"code":"var _jsxFileName = \"/Users/leeheejun/Desktop/query/base-infinite-swapi/src/people/InfinitePeople.jsx\",\n  _s = $RefreshSig$();\nimport InfiniteScroll from 'react-infinite-scroller';\nimport { Person } from './Person';\nimport { useInfiniteQuery } from 'react-query';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialUrl = 'https://swapi.dev/api/people/';\nconst fetchUrl = async url => {\n  const response = await fetch(url);\n  return response.json();\n};\nexport function InfinitePeople() {\n  _s();\n  // fetchNextPage는 더 많은 데이터가 필요할 때 어느 함수를 실행할지를 infiniteScroll에 지시하는 역할을 한다.\n  // hasNextPage는 수집할 데이터가 더 있는지를 결정하는 불리언이다.\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isLoading,\n    isError\n  } = useInfiniteQuery('sw-people', _ref => {\n    let {\n      pageParam = initialUrl\n    } = _ref;\n    return fetchUrl(pageParam);\n  },\n  // useInfiniteQuery의 모든것은 pageParam에 달려 있다. pageParam은 fetchNextPage가 어떻게 보일지 결정하고 다음 페이지가 있는지 결정한다.\n\n  {\n    getNextPageParam: lastPage => lastPage.next || undefined\n  });\n  if (isLoading) return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"loading\",\n    children: \"Loading...\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 26,\n    columnNumber: 25\n  }, this);\n  if (isError) return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [\"Error! \", error.toString()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 23\n  }, this);\n  return /*#__PURE__*/_jsxDEV(InfiniteScroll, {\n    loadMore: fetchNextPage,\n    hasMore: hasNextPage,\n    children: data.pages.map(pageData => {\n      return pageData.results.map(person => {\n        // pageData는 각 페이지에 useInfiniteQuery가 fetchNextPage로 불러온 데이터 배열을 맵핑한다.\n        return /*#__PURE__*/_jsxDEV(Person, {\n          name: person.name,\n          hairColor: person.hair_color,\n          eyeColor: person.eye_color\n        }, person.name, false, {\n          fileName: _jsxFileName,\n          lineNumber: 34,\n          columnNumber: 13\n        }, this);\n      });\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 29,\n    columnNumber: 5\n  }, this);\n}\n_s(InfinitePeople, \"4zRDQJHCxSW54U9T49sz5tIpit4=\", false, function () {\n  return [useInfiniteQuery];\n});\n_c = InfinitePeople;\nvar _c;\n$RefreshReg$(_c, \"InfinitePeople\");","map":{"version":3,"names":["InfiniteScroll","Person","useInfiniteQuery","initialUrl","fetchUrl","url","response","fetch","json","InfinitePeople","data","fetchNextPage","hasNextPage","isLoading","isError","pageParam","getNextPageParam","lastPage","next","undefined","error","toString","pages","map","pageData","results","person","name","hair_color","eye_color"],"sources":["/Users/leeheejun/Desktop/query/base-infinite-swapi/src/people/InfinitePeople.jsx"],"sourcesContent":["import InfiniteScroll from 'react-infinite-scroller';\nimport { Person } from './Person';\n\nimport { useInfiniteQuery } from 'react-query';\n\nconst initialUrl = 'https://swapi.dev/api/people/';\nconst fetchUrl = async (url) => {\n  const response = await fetch(url);\n  return response.json();\n};\n\nexport function InfinitePeople() {\n  // fetchNextPage는 더 많은 데이터가 필요할 때 어느 함수를 실행할지를 infiniteScroll에 지시하는 역할을 한다.\n  // hasNextPage는 수집할 데이터가 더 있는지를 결정하는 불리언이다.\n  const { data, fetchNextPage, hasNextPage, isLoading, isError } =\n    useInfiniteQuery(\n      'sw-people',\n      ({ pageParam = initialUrl }) => fetchUrl(pageParam),\n      // useInfiniteQuery의 모든것은 pageParam에 달려 있다. pageParam은 fetchNextPage가 어떻게 보일지 결정하고 다음 페이지가 있는지 결정한다.\n\n      {\n        getNextPageParam: (lastPage) => lastPage.next || undefined,\n      }\n    );\n\n  if (isLoading) return <div className=\"loading\">Loading...</div>;\n  if (isError) return <div>Error! {error.toString()}</div>;\n  return (\n    <InfiniteScroll loadMore={fetchNextPage} hasMore={hasNextPage}>\n      {data.pages.map((pageData) => {\n        return pageData.results.map((person) => {\n          // pageData는 각 페이지에 useInfiniteQuery가 fetchNextPage로 불러온 데이터 배열을 맵핑한다.\n          return (\n            <Person\n              key={person.name}\n              name={person.name}\n              hairColor={person.hair_color}\n              eyeColor={person.eye_color}\n            />\n          );\n        });\n      })}\n    </InfiniteScroll>\n  );\n}\n"],"mappings":";;AAAA,OAAOA,cAAc,MAAM,yBAAyB;AACpD,SAASC,MAAM,QAAQ,UAAU;AAEjC,SAASC,gBAAgB,QAAQ,aAAa;AAAC;AAE/C,MAAMC,UAAU,GAAG,+BAA+B;AAClD,MAAMC,QAAQ,GAAG,MAAOC,GAAG,IAAK;EAC9B,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;EACjC,OAAOC,QAAQ,CAACE,IAAI,EAAE;AACxB,CAAC;AAED,OAAO,SAASC,cAAc,GAAG;EAAA;EAC/B;EACA;EACA,MAAM;IAAEC,IAAI;IAAEC,aAAa;IAAEC,WAAW;IAAEC,SAAS;IAAEC;EAAQ,CAAC,GAC5DZ,gBAAgB,CACd,WAAW,EACX;IAAA,IAAC;MAAEa,SAAS,GAAGZ;IAAW,CAAC;IAAA,OAAKC,QAAQ,CAACW,SAAS,CAAC;EAAA;EACnD;;EAEA;IACEC,gBAAgB,EAAGC,QAAQ,IAAKA,QAAQ,CAACC,IAAI,IAAIC;EACnD,CAAC,CACF;EAEH,IAAIN,SAAS,EAAE,oBAAO;IAAK,SAAS,EAAC,SAAS;IAAA,UAAC;EAAU;IAAA;IAAA;IAAA;EAAA,QAAM;EAC/D,IAAIC,OAAO,EAAE,oBAAO;IAAA,WAAK,SAAO,EAACM,KAAK,CAACC,QAAQ,EAAE;EAAA;IAAA;IAAA;IAAA;EAAA,QAAO;EACxD,oBACE,QAAC,cAAc;IAAC,QAAQ,EAAEV,aAAc;IAAC,OAAO,EAAEC,WAAY;IAAA,UAC3DF,IAAI,CAACY,KAAK,CAACC,GAAG,CAAEC,QAAQ,IAAK;MAC5B,OAAOA,QAAQ,CAACC,OAAO,CAACF,GAAG,CAAEG,MAAM,IAAK;QACtC;QACA,oBACE,QAAC,MAAM;UAEL,IAAI,EAAEA,MAAM,CAACC,IAAK;UAClB,SAAS,EAAED,MAAM,CAACE,UAAW;UAC7B,QAAQ,EAAEF,MAAM,CAACG;QAAU,GAHtBH,MAAM,CAACC,IAAI;UAAA;UAAA;UAAA;QAAA,QAIhB;MAEN,CAAC,CAAC;IACJ,CAAC;EAAC;IAAA;IAAA;IAAA;EAAA,QACa;AAErB;AAAC,GAjCelB,cAAc;EAAA,QAI1BP,gBAAgB;AAAA;AAAA,KAJJO,cAAc;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}